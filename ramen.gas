/****************************************************
 * æ‹‰éºµåº—å€™ä½ç³»çµ±ï¼ˆæ•´åˆï¼‹æŸ¥è©¢ï¼‹æ¯æ—¥äººæ•¸ä¸Šé™ï¼‹å–®çµ„ä¸Šé™ï¼‹é¡æ»¿æç¤º
 *  ï¼‹æ¬ç§»éä»Šæ—¥åˆ° archiveï¼‹æ’åºè¦å‰‡å¼·åŒ–ï¼ˆä¿æŒ waiting/called ç›¸å°é †åºï¼‰
 *  ï¼‹å–æ¶ˆå³åˆ»æ­¸æª”ï¼‹æ–°å¢/å«è™Ÿè‡ªå‹•é‡æ’ï¼‹æŒ‡å®šè™Ÿç¢¼å«è™Ÿï¼‰
 *
 * ğŸ”‘ æ’åºé‚è¼¯ï¼ˆreorderQueueï¼‰ï¼š
 *   - ä»Šæ—¥ Activeï¼šstatus ç‚º waiting/called ä¸”ã€Œééè™Ÿã€â†’ ä¿æŒåŸè¡Œåº
 *   - ä»Šæ—¥ Skippedï¼šstatus ç‚º waiting ä¸”ç¬¬7æ¬„å« "SKIPPED " â†’ ä¿æŒåŸè¡Œåº
 *   - ä»Šæ—¥ Closedï¼šstatus ç‚º done/cancelled â†’ ä¿æŒåŸè¡Œåº
 *   - Othersï¼šéä»Šæ—¥ â†’ ä¿æŒåŸè¡Œåº
 *   åˆä½µé †åºï¼šActive â†’ Skipped â†’ Closed â†’ Others
 *   âœ… æ–°å¢å€™ä½ appendRow å¾Œï¼Œé‡æ’åªåšåˆ†æ®µæ‹¼æ¥ï¼Œæ–°åŠ å…¥æœƒè‡ªç„¶ç•™åœ¨ Active å€å¡Šåº•éƒ¨ã€‚
 *
 * ğŸ§® ç•¶æ—¥äººæ•¸ä¸Šé™ï¼ˆé‡è¦è®Šæ›´ï¼‰ï¼š
 *   - ã€Œä»Šæ—¥å·²ä½¿ç”¨äººæ•¸ã€ = ä»Šæ—¥ waiting + called + done çš„äººæ•¸ç¸½å’Œ
 *   - canAcceptMoreToday / getTodayPeopleRemaining éƒ½æ”¹ç”¨ä¸Šè¿°ç¸½å’Œ
 ****************************************************/

const SHEET_NAME = 'queue';
const ARCHIVE_SHEET_NAME = 'archive';
const PREFIX = 'A';
const PROP = PropertiesService.getScriptProperties();

/********** Spreadsheet åŸºæœ¬ **********/
function getSpreadsheet() {
  const sid = PROP.getProperty('SHEET_ID');
  return sid ? SpreadsheetApp.openById(sid) : SpreadsheetApp.getActiveSpreadsheet();
}
function sheet() {
  const ss = getSpreadsheet();
  const sh = ss.getSheetByName(SHEET_NAME) || ss.insertSheet(SHEET_NAME);
  if (sh.getLastRow() === 0) {
    sh.appendRow(['id','name','party_size','user_id','status','created_at','flag_or_notified']);
  }
  return sh;
}
function archiveSheet() {
  const ss = getSpreadsheet();
  const sh = ss.getSheetByName(ARCHIVE_SHEET_NAME) || ss.insertSheet(ARCHIVE_SHEET_NAME);
  if (sh.getLastRow() === 0) {
    sh.appendRow(['id','name','party_size','user_id','status','created_at','flag_or_notified']);
  }
  return sh;
}

/********** æ™‚é–“/æ——æ¨™ **********/
function nowISO() { return new Date().toISOString(); }
function isTodayLocal(iso) {
  if (!iso) return false;
  const tz = Session.getScriptTimeZone() || 'Asia/Taipei';
  const d = new Date(iso);
  const today = new Date();
  const ds = Utilities.formatDate(d, tz, 'yyyy-MM-dd');
  const ts = Utilities.formatDate(today, tz, 'yyyy-MM-dd');
  return ds === ts;
}
function isSkippedFlag(row7) {
  return typeof row7 === 'string' && row7.indexOf('SKIPPED ') === 0;
}

/********** åƒæ•¸/é™åˆ¶ **********/
function getAvgMinutesPerGroup() {
  const v = Number(PROP.getProperty('AVG_MIN_PER_GROUP') || '10');
  return isNaN(v) || v <= 0 ? 10 : v;
}
function getPartySizeMax() {
  const v = Number(PROP.getProperty('PARTY_SIZE_MAX') || '5');
  return (isNaN(v) || v <= 0) ? 5 : v;
}

/********** è³‡æ–™å­˜å– & æŸ¥æ‰¾ **********/
function nextTicket() {
  const key = 'COUNTER';
  let n = Number(PROP.getProperty(key) || '0');
  n += 1;
  PROP.setProperty(key, String(n));
  return PREFIX + String(n).padStart(2, '0');
}
function getAll() {
  const sh = sheet();
  const last = sh.getLastRow();
  if (last < 2) return [];
  const values = sh.getRange(2, 1, last - 1, 7).getValues();
  return values.map(r => ({
    id: r[0], name: r[1], party_size: Number(r[2]), user_id: r[3],
    status: r[4], created_at: r[5], flag_or_notified: r[6],
  }));
}
function findByUser(userId) {
  return getAll().find(r =>
    r.user_id === userId && (r.status === 'waiting' || r.status === 'called')
  );
}
function findRowById(id) {
  const sh = sheet();
  const last = sh.getLastRow();
  if (last < 2) return -1;
  const ids = sh.getRange(2, 1, last - 1, 1).getValues().map(v => v[0]);
  const idx = ids.indexOf(id);
  return idx === -1 ? -1 : idx + 2;
}
function positionOf(id) {
  const waiting = getAll().filter(r => r.status === 'waiting');
  return waiting.findIndex(r => r.id === id);
}
function getCurrentNumber() {
  const cur = getAll().find(r => r.status === 'called');
  return cur ? cur.id : null;
}

/********** ã€Œä»Šæ—¥äººæ•¸ã€è¼”åŠ©ï¼ˆå« waiting/called/doneï¼‰ **********/
function getTotalPeopleByStatusesToday(statuses) {
  const set = new Set(statuses || []);
  return getAll()
    .filter(r => isTodayLocal(r.created_at) && set.has(r.status))
    .reduce((sum, r) => sum + (Number(r.party_size) || 0), 0);
}
function getTotalGroupsByStatusesToday(statuses) {
  const set = new Set(statuses || []);
  return getAll()
    .filter(r => isTodayLocal(r.created_at) && set.has(r.status))
    .length;
}
function getTotalUsedPeopleToday() {
  // ä»Šæ—¥å·²ä½¿ç”¨äººæ•¸ = waiting + called + done
  return getTotalPeopleByStatusesToday(['waiting','called','done']);
}

/********** æ–°å¢/æ›´æ–°/å–æ¶ˆ/å«è™Ÿ **********/
function addWaiting(name, size, userId) {
  const sh = sheet();
  const id = nextTicket();
  sh.appendRow([id, name, size, userId || '', 'waiting', nowISO(), '']);
  reorderQueue(); // æ–°å¢å¾Œæ’åœ¨ Active å€å¡Šåº•éƒ¨
  return { id, name, party_size: size, user_id: userId || '', status: 'waiting' };
}
function archiveById(id, statusOverride) {
  const r = findRowById(id);
  if (r === -1) return false;
  const main = sheet();
  const arch = archiveSheet();
  const row = main.getRange(r, 1, 1, 7).getValues()[0];
  row[4] = statusOverride || row[4] || 'cancelled';
  arch.getRange(arch.getLastRow() + 1, 1, 1, 7).setValues([row]);
  main.deleteRow(r);
  return true;
}
function updateStatusById(id, status) {
  if (status === 'cancelled') {
    return archiveById(id, 'cancelled'); // å–æ¶ˆå³åˆ»æ­¸æª”
  }
  const r = findRowById(id);
  if (r === -1) return false;
  sheet().getRange(r, 5).setValue(status);
  if (status === 'done') reorderQueue(); // å®Œæˆå¾Œé‡æ’ï¼ˆåªæ‹¼æ®µï¼Œä¸æ‰“äº‚ Active å…§é †åºï¼‰
  return true;
}
function uncallAllExcept(exceptId) {
  const sh = sheet();
  const last = sh.getLastRow();
  if (last < 2) return 0;
  const range = sh.getRange(2, 1, last - 1, 7);
  const values = range.getValues();
  let changed = 0;
  for (let i = 0; i < values.length; i++) {
    const row = values[i];
    if (row[4] === 'called' && row[0] !== exceptId) {
      row[4] = 'waiting';
      values[i] = row;
      changed++;
    }
  }
  if (changed > 0) range.setValues(values);
  return changed;
}
function callNext() {
  const next = getAll().find(r => r.status === 'waiting');
  if (!next) return null;
  uncallAllExcept(next.id);          // å–®ä¸€å«è™Ÿæ¨¡å¼
  updateStatusById(next.id, 'called');
  linePush(next.user_id, [{ type: 'text', text: 'è¼ªåˆ°æ‚¨å›‰ï¼è«‹è‡³æ«ƒæª¯å ±åˆ°ï¼ˆè™Ÿç¢¼ï¼š' + next.id + 'ï¼‰' }]);
  reorderQueue();                    // é‡æ’åˆ†æ®µï¼Œä½†ä¸æ”¹ Active å…§ç›¸å°é †åº
  return next;
}
function callById(id) {
  const r = findRowById(id);
  if (r === -1) return { ok:false, reason:'not_found' };
  const sh = sheet();
  const row = sh.getRange(r, 1, 1, 7).getValues()[0];
  const status = row[4];
  if (status !== 'waiting' && status !== 'called') {
    return { ok:false, reason:'not_waiting_or_called', status };
  }
  uncallAllExcept(row[0]);           // å–®ä¸€å«è™Ÿ
  sh.getRange(r, 5).setValue('called'); // åªæ”¹ç‹€æ…‹ï¼Œä¸ç§»å‹•è¡Œ
  const userId = row[3];
  if (userId) linePush(userId, [{ type: 'text', text: 'è¼ªåˆ°æ‚¨å›‰ï¼è«‹è‡³æ«ƒæª¯å ±åˆ°ï¼ˆè™Ÿç¢¼ï¼š' + row[0] + 'ï¼‰' }]);
  reorderQueue();
  return { ok:true, called: { id: row[0], name: row[1], party_size: row[2], user_id: userId } };
}
function cancelByUser(userId) {
  const item = findByUser(userId);
  if (!item || item.status !== 'waiting') return null;
  updateStatusById(item.id, 'cancelled'); // å…§éƒ¨æœƒ archive
  return item;
}

/********** éè™Ÿï¼ˆå‘ä¸‹ç§» 3 åˆ— + é€šçŸ¥ + æ¨™è¨˜ SKIPPEDï¼‰ **********/
function skipIdDownThree(id) {
  const sh = sheet();
  const r = findRowById(id);
  if (r === -1) return { ok: false, reason: 'not_found' };
  const last = sh.getLastRow();
  if (last < 2) return { ok: false, reason: 'empty' };

  const row = sh.getRange(r, 1, 1, 7).getValues()[0];
  const status = row[4];
  const userId = row[3];
  if (status !== 'waiting' && status !== 'called') {
    return { ok: false, reason: 'not_waiting_or_called', status };
  }

  // æ¨™è¨˜ç‚ºéè™Ÿ
  row[4] = 'waiting';
  row[6] = 'SKIPPED ' + nowISO();

  // åˆªåŸåˆ— â†’ ä¸‹ç§» 3 åˆ—æ’å…¥ï¼ˆè¶…å‡ºå‰‡ appendï¼‰
  sh.deleteRow(r);
  const currentLast = sh.getLastRow();
  const targetIndex = Math.min(r + 3, currentLast + 1);
  const safeIndex = Math.max(2, targetIndex);
  if (safeIndex === currentLast + 1) {
    sh.appendRow(row);
  } else {
    sh.insertRowsBefore(safeIndex, 1);
    sh.getRange(safeIndex, 1, 1, 7).setValues([row]);
  }

  const pos = positionOf(id);
  const cur = getCurrentNumber();
  const minutes = (pos >= 0) ? pos * getAvgMinutesPerGroup() : null;
  const advice = (minutes !== null) ? ('\nå»ºè­°æ–¼ ' + minutes + ' åˆ†é˜å…§å›åˆ°ç¾å ´') : '';

  if (userId) {
    const msg =
      'æ‚¨å·²éè™Ÿï¼Œè™Ÿç¢¼ï¼š' + id +
      '\nç›®å‰è™Ÿç¢¼ï¼š' + (cur || 'å°šæœªå«è™Ÿ') +
      '\næ‚¨çš„è™Ÿç¢¼ï¼š' + id +
      '\nå‰é¢é‚„æœ‰å¹¾çµ„ï¼š' + (pos >= 0 ? pos : 'â€”') +
      advice +
      '\nå¦‚å·²åˆ°åº—ï¼Œè«‹ç›¡é€Ÿè‡³æ«ƒæª¯å ±åˆ°ã€‚';
    linePush(userId, [{ type: 'text', text: msg }]);
  }

  reorderQueue();
  return { ok: true, id, new_status: 'waiting', moved_to_row: safeIndex, position: pos };
}

/********** æ’åºï¼ˆä¿æŒå€æ®µå…§åŸè¡Œåºï¼‰ **********/
function reorderQueue() {
  const sh = sheet();
  const last = sh.getLastRow();
  if (last < 2) return;

  const values = sh.getRange(2, 1, last - 1, 7).getValues();
  const todayActive = [];   // ä»Šæ—¥ waiting/calledï¼ˆæœªéè™Ÿï¼‰â€”ä¿æŒåŸè¡Œåº
  const todaySkipped = [];  // ä»Šæ—¥ waiting & SKIPPED â€”ä¿æŒåŸè¡Œåº
  const todayClosed = [];   // ä»Šæ—¥ done/cancelled â€”ä¿æŒåŸè¡Œåº
  const others = [];        // éä»Šæ—¥ â€”ä¿æŒåŸè¡Œåº

  for (const row of values) {
    const status = row[4];
    const createdAt = row[5];
    const flag = row[6];

    if (!isTodayLocal(createdAt)) {
      others.push(row);
      continue;
    }
    if (status === 'waiting' || status === 'called') {
      if (status === 'waiting' && isSkippedFlag(flag)) {
        todaySkipped.push(row);
      } else {
        todayActive.push(row);
      }
    } else if (status === 'done' || status === 'cancelled') {
      todayClosed.push(row);
    } else {
      todayClosed.push(row);
    }
  }

  const merged = todayActive.concat(todaySkipped, todayClosed, others);
  if (last > 1) sh.getRange(2, 1, last - 1, 7).clearContent();
  if (merged.length > 0) sh.getRange(2, 1, merged.length, 7).setValues(merged);
}

/********** æ¬ç§»éä»Šæ—¥è³‡æ–™åˆ° archive **********/
function archiveOldRows() {
  const main = sheet();
  const arch = archiveSheet();
  const last = main.getLastRow();
  if (last < 2) return { moved: 0, kept: 0 };

  const values = main.getRange(2, 1, last - 1, 7).getValues();
  const toKeep = [];
  const toMove = [];
  for (const row of values) {
    const createdAt = row[5];
    if (isTodayLocal(createdAt)) toKeep.push(row);
    else toMove.push(row);
  }
  if (toMove.length > 0) {
    arch.getRange(arch.getLastRow() + 1, 1, toMove.length, 7).setValues(toMove);
  }
  if (last > 1) main.getRange(2, 1, last - 1, 7).clearContent();
  if (toKeep.length > 0) main.getRange(2, 1, toKeep.length, 7).setValues(toKeep);
  return { moved: toMove.length, kept: toKeep.length };
}
function setupDailyArchiveTrigger() {
  const name = 'archiveOldRows';
  ScriptApp.getProjectTriggers().filter(t => t.getHandlerFunction() === name).forEach(t => ScriptApp.deleteTrigger(t));
  ScriptApp.newTrigger(name).timeBased().atHour(3).everyDays(1).create(); // æ¯å¤© 03:00
}

/********** çµ±è¨ˆ & ä¸Šé™ **********/
function getTotalWaitingGroups() {
  return getAll().filter(r => r.status === 'waiting').length;
}
function getTotalWaitingPeople() {
  return getAll().filter(r => r.status === 'waiting')
    .reduce((sum, r) => sum + (Number(r.party_size) || 0), 0);
}
function getDailyPeopleLimitMap() {
  try {
    const raw = PROP.getProperty('DAILY_PEOPLE_LIMITS');
    if (!raw) return {};
    const obj = JSON.parse(raw);
    return (obj && typeof obj === 'object') ? obj : {};
  } catch (e) { return {}; }
}
function setDailyPeopleLimit(weekday, people) {
  const map = getDailyPeopleLimitMap();
  map[String(weekday)] = Number(people);
  PROP.setProperty('DAILY_PEOPLE_LIMITS', JSON.stringify(map));
  return map;
}
function setDailyPeopleLimitFromJson(jsonStr) {
  const obj = JSON.parse(jsonStr);
  if (!obj || typeof obj !== 'object') throw new Error('invalid_json');
  const map = {};
  for (let k of Object.keys(obj)) {
    if (!/^[0-6]$/.test(k)) continue;
    const v = Number(obj[k]);
    if (isNaN(v) || v <= 0) continue;
    map[k] = v;
  }
  PROP.setProperty('DAILY_PEOPLE_LIMITS', JSON.stringify(map));
  return map;
}
function getTodayPeopleLimit() {
  const map = getDailyPeopleLimitMap();
  const today = new Date().getDay(); // 0=Sun..6=Sat
  const v = map.hasOwnProperty(String(today)) ? Number(map[String(today)]) : null;
  return (v && v > 0) ? v : null;
}
/** ä»Šæ—¥å‰©é¤˜åé¡ï¼ˆäººæ•¸ï¼‰ï¼›æœªè¨­å®šå› nullã€‚ä½¿ç”¨ã€Œä»Šæ—¥ waiting+called+doneã€çš„äººæ•¸ç¸½å’Œã€‚ */
function getTodayPeopleRemaining() {
  const limit = getTodayPeopleLimit();
  if (limit === null) return null;
  const used = getTotalUsedPeopleToday(); // waiting + called + doneï¼ˆåƒ…ä»Šæ—¥ï¼‰
  return Math.max(0, limit - used);
}
/** æ˜¯å¦å¯æ¥å—æ–°å¢ size äººï¼ˆè€ƒé‡ä»Šæ—¥ä¸Šé™ï¼›æœªè¨­å®šä¸Šé™å‰‡ä¸€å¾‹å¯ï¼‰ã€‚ä½¿ç”¨ã€Œä»Šæ—¥ waiting+called+doneã€ã€‚ */
function canAcceptMoreToday(size) {
  const limit = getTodayPeopleLimit();
  if (limit === null) return true;
  const used = getTotalUsedPeopleToday();
  return used + size <= limit;
}

/********** LINE API **********/
function lineReply(replyToken, messages) {
  const token = PROP.getProperty('LINE_CHANNEL_ACCESS_TOKEN');
  if (!token) return;
  UrlFetchApp.fetch('https://api.line.me/v2/bot/message/reply', {
    method: 'post',
    contentType: 'application/json',
    headers: { Authorization: 'Bearer ' + token },
    payload: JSON.stringify({ replyToken, messages }),
    muteHttpExceptions: true,
  });
}
function linePush(toUserId, messages) {
  const token = PROP.getProperty('LINE_CHANNEL_ACCESS_TOKEN');
  if (!token) return;
  if (!toUserId) return;
  UrlFetchApp.fetch('https://api.line.me/v2/bot/message/push', {
    method: 'post',
    contentType: 'application/json',
    headers: { Authorization: 'Bearer ' + token },
    payload: JSON.stringify({ to: toUserId, messages }),
    muteHttpExceptions: true,
  });
}

/********** Webhook (POST) for LINE **********/
function doPost(e) {
  // ä½¿ç”¨é–å®šç¢ºä¿åŒä¸€æ™‚é–“åªæœ‰ä¸€å€‹è«‹æ±‚è™•ç†è³‡æ–™ï¼Œé¿å…ä½µç™¼æ™‚äº‚åºæˆ–é‡è¦†
  const lock = LockService.getScriptLock();
  const gotLock = lock.tryLock(30000); // æœ€é•·ç­‰å¾… 30 ç§’
  try {
    // è‹¥ç„¡æ³•å–å¾—é–ï¼Œå¿«é€Ÿå›è¦†ã€Œç³»çµ±å¿™ç¢Œã€
    if (!gotLock) {
      const raw = e.postData && e.postData.contents ? e.postData.contents : '{}';
      const body = JSON.parse(raw);
      const event = body.events && body.events[0];
      if (event && event.replyToken) {
        lineReply(event.replyToken, [{ type:'text', text:'ç³»çµ±å¿™ç¢Œï¼Œè«‹ç¨å¾Œå†è©¦ ğŸ™‡â€â™‚ï¸' }]);
      }
      return ContentService.createTextOutput('OK'); // å›å‚³ 200ï¼Œé¿å… LINE é‡è©¦
    }

    try {
      const raw = e.postData && e.postData.contents ? e.postData.contents : '{}';
      const body = JSON.parse(raw);
      const event = body.events && body.events[0];
      if (!event) return ContentService.createTextOutput('OK');

      if (event.type === 'message' && event.message && event.message.type === 'text') {
        const replyToken = event.replyToken;
        const userId = event.source && event.source.userId;
        const text = (event.message.text || '').trim();
        const reply = (msg) => lineReply(replyToken, [{ type: 'text', text: msg }]);

        if (!userId) {
          reply('ç„¡æ³•å–å¾—ä½¿ç”¨è€…IDï¼Œè«‹ç¨å¾Œå†è©¦');
        } else if (text === 'æˆ‘è¦å€™ä½') {
          const remaining = getTodayPeopleRemaining(); // å¯èƒ½ç‚º nullï¼ˆæœªè¨­å®šä¸Šé™ï¼‰
          const maxPerGroup = getPartySizeMax();
          const used = getTotalUsedPeopleToday();      // ä»Šæ—¥å·²ç´¯è¨ˆï¼ˆwaiting+called+doneï¼‰
          const waitingPeople = getTotalWaitingPeople();

          if (remaining !== null && remaining <= 0) {
            const limit = getTodayPeopleLimit();
            reply(
              'å¾ˆæŠ±æ­‰ï¼Œä»Šæ—¥å€™ä½å·²é¡æ»¿ ğŸ™‡â€â™‚ï¸' +
              '\nä»Šæ—¥ä¸Šé™äººæ•¸ï¼š' + limit + ' äºº' +
              '\nä»Šæ—¥å·²ç´¯è¨ˆäººæ•¸ï¼ˆå«å«è™Ÿ/å®Œæˆï¼‰ï¼š' + used + ' äºº' +
              '\nç›®å‰ç­‰å¾…äººæ•¸ï¼š' + waitingPeople + ' äºº' +
              '\nå»ºè­°ï¼šå¯æ”¹å¤©å†ä¾†ï¼Œæˆ–ç¾å ´è¦–æƒ…æ³å€™è£œã€‚æ„Ÿè¬é«”è«’ï¼'
            );
          } else {
            const extra = (remaining === null)
              ? ''
              : ('\nï¼ˆä»Šæ—¥å‰©é¤˜åé¡ï¼š' + remaining + ' äººï¼›å·²ç´¯è¨ˆï¼š' + used + ' äººï¼‰');
            reply('è«‹è¼¸å…¥ å§“å/äººæ•¸ï¼ˆå–®çµ„ä¸Šé™ ' + maxPerGroup + ' äººï¼‰ï¼Œä¾‹å¦‚ï¼šç‹å°æ˜/2ï¼Œè«‹å°‡å°æœ‹å‹ä¹Ÿç®—é€²äººæ•¸å…§ï¼ï¼å¡«å¯«ç¸½äººæ•¸ï¼ï¼' + extra);
          }
        } else if (text === 'æŸ¥è©¢') {
          const groups = getTotalWaitingGroups();
          const people = getTotalWaitingPeople();
          const limitPeople = getTodayPeopleLimit();
          const limitText = (limitPeople === null) ? 'æœªè¨­å®š' : String(limitPeople);
          const used = getTotalUsedPeopleToday();

          const item = findByUser(userId);
          if (!item) {
            reply(
              'ç›®å‰ç­‰å¾…ç¸½çµ„æ•¸ï¼š' + groups +
              '\nç›®å‰ç­‰å¾…ç¸½äººæ•¸ï¼š' + people +
              '\nä»Šæ—¥ä¸Šé™äººæ•¸ï¼š' + limitText +
              '\nä»Šæ—¥å·²ç´¯è¨ˆäººæ•¸ï¼ˆå«å«è™Ÿ/å®Œæˆï¼‰ï¼š' + used
            );
          } else {
            let pos = (item.status === 'called') ? 0 : positionOf(item.id);
            if (pos < 0) pos = 0;
            const etaMin = pos * getAvgMinutesPerGroup();
            reply(
              'ç›®å‰ç­‰å¾…ç¸½çµ„æ•¸ï¼š' + groups +
              '\nç›®å‰ç­‰å¾…ç¸½äººæ•¸ï¼š' + people +
              '\nä»Šæ—¥ä¸Šé™äººæ•¸ï¼š' + limitText +
              '\nä»Šæ—¥å·²ç´¯è¨ˆäººæ•¸ï¼ˆå«å«è™Ÿ/å®Œæˆï¼‰ï¼š' + used +
              '\nå‰é¢é‚„æœ‰å¹¾çµ„ï¼š' + pos +
              '\né è¨ˆç­‰å¾…æ™‚é–“ï¼š' + etaMin + ' åˆ†é˜'
            );
          }
        } else if (text === 'å–æ¶ˆå€™ä½') {
          const item = cancelByUser(userId);
          if (!item) reply('æ‰¾ä¸åˆ°æ‚¨çš„å€™ä½ç´€éŒ„æˆ–å·²éç­‰å¾…ä¸­');
          else reply('å·²ç‚ºæ‚¨å–æ¶ˆä¸¦æ­¸æª”ï¼š' + item.id + 'ï¼ŒæœŸå¾…ä¸‹æ¬¡å…‰è‡¨ ğŸœ');
        } else if (text.indexOf('/') !== -1) {
          const parts = text.split('/');
          const name = (parts[0] || '').trim();
          const size = parseInt((parts[1] || '').replace(/[äººä½ppläººæ•¸]/g, ''), 10);
          const maxSize = getPartySizeMax();

          if (!name || !size || size <= 0) {
            reply('æ ¼å¼éŒ¯èª¤ï¼Œè«‹è¼¸å…¥ï¼šå§“å/äººæ•¸ï¼ˆä¾‹ï¼šç‹å°æ˜/2ï¼‰');
          } else if (size > maxSize) {
            reply('å¾ˆæŠ±æ­‰ï¼Œæœ¬åº—å–®çµ„ä¸Šé™ç‚º ' + maxSize + ' äººã€‚\nè‹¥è¶…éä¸Šé™ï¼Œè«‹åˆ†æˆå¤šçµ„å€™ä½ï¼Œæ„Ÿè¬é…åˆï¼');
          } else if (!canAcceptMoreToday(size)) {
            const limit = getTodayPeopleLimit();
            const used = getTotalUsedPeopleToday();
            const waiting = getTotalWaitingPeople();
            const remaining = Math.max(0, (limit || 0) - used);
            reply(
              'å¾ˆæŠ±æ­‰ï¼Œä»Šæ—¥å€™ä½äººæ•¸å·²æ¥è¿‘æˆ–è¶…éä¸Šé™ã€‚\n' +
              'ä»Šæ—¥ä¸Šé™ï¼š' + limit + ' äºº' +
              '\nä»Šæ—¥å·²ç´¯è¨ˆäººæ•¸ï¼ˆå«å«è™Ÿ/å®Œæˆï¼‰ï¼š' + used + ' äºº' +
              '\nç›®å‰ç­‰å¾…äººæ•¸ï¼š' + waiting + ' äºº' +
              '\nå‰©é¤˜åé¡ï¼š' + remaining + ' äºº' +
              '\nå¦‚éœ€å€™ä½ï¼Œè«‹åˆ†æ‰¹æˆ–æ”¹æ—¥å†ä¾†ï¼Œè¬è¬ç†è§£ã€‚'
            );
          } else {
            const exists = findByUser(userId);
            if (exists) {
              reply('æ‚¨å·²åœ¨å€™ä½åå–®ä¸­ï¼Œè™Ÿç¢¼ï¼š' + exists.id + 'ï¼ˆè¼¸å…¥ã€ŒæŸ¥è©¢ã€æŸ¥çœ‹é€²åº¦ï¼Œæˆ–ã€Œå–æ¶ˆå€™ä½ã€å–æ¶ˆï¼‰');
            } else {
              const item = addWaiting(name, size, userId); // å…§å«è‡ªå‹•é‡æ’ï¼ˆæ–°é …åœ¨åº•éƒ¨ï¼‰
              const pos = positionOf(item.id);
              reply('å·²ç™»è¨˜å€™ä½ï¼\nè™Ÿç¢¼ï¼š' + item.id + '\näººæ•¸ï¼š' + size + '\nå‰é¢é‚„æœ‰ ' + pos + ' çµ„');
            }
          }
        } else {
          reply('è¼¸å…¥ã€Œæˆ‘è¦å€™ä½ã€é–‹å§‹ï¼›ã€ŒæŸ¥è©¢ã€çœ‹é€²åº¦ï¼›ã€Œå–æ¶ˆå€™ä½ã€å¯å–æ¶ˆã€‚');
        }
      }
      return ContentService.createTextOutput('OK');
    } catch (err) {
      // æ•æ‰å…§éƒ¨éŒ¯èª¤ä¹Ÿå› 200ï¼Œé¿å… LINE é‡è¤‡é‡é€
      return ContentService.createTextOutput('OK');
    }
  } finally {
    if (gotLock) lock.releaseLock();
  }
}

/********** ç®¡ç†ç«¯ / å¥åº·æª¢æŸ¥ (GET) **********
 * health=1ï¼šä¸éœ€ token
 * å…¶é¤˜ action éœ€ ADMIN_TOKENï¼š
 *  - list
 *  - call                 â†’ å«ä¸‹ä¸€çµ„ï¼ˆå–®ä¸€å«è™Ÿã€æ¨æ’­ã€é‡æ’ï¼‰
 *  - call&id=A05          â†’ æŒ‡å®šè™Ÿç¢¼å«è™Ÿï¼ˆå–®ä¸€å«è™Ÿã€æ¨æ’­ã€é‡æ’ï¼‰
 *  - skip&id=A01          â†’ éè™Ÿï¼ˆå‘ä¸‹ç§»3åˆ—ï¼Œæ¨æ’­ï¼Œé‡æ’ï¼‰
 *  - cancel&id=A01        â†’ å–æ¶ˆï¼ˆç«‹å³ç§»è‡³ archiveï¼‰
 *  - done&id=A01          â†’ å®Œæˆï¼ˆé‡æ’ï¼‰
 *  - add&name=ç‹å°æ˜&size=2&userId=Uxxxï¼ˆå¯ç•™ç©ºï¼‰
 *  - getLimits / setLimit / setLimits
 *  - reorder              â†’ åªåšåˆ†æ®µæ‹¼æ¥ï¼Œä¸æ”¹å‹• waiting/called ç›¸å°é †åº
 *  - archive              â†’ æ¬ç§»ã€Œéä»Šæ—¥ã€åˆ° archive
 *  - version
 *************************************************/
function doGet(e) {
  const p = e.parameter || {};

  if (p.health === '1') {
    return ContentService.createTextOutput('OK').setMimeType(ContentService.MimeType.TEXT);
  }
  if (p.action === 'version') {
    return ContentService.createTextOutput(JSON.stringify({
      ok: true,
      version: '2025-09-08T11:10+08:00',
      features: [
        'list+totals(people/groups)+limits',
        'call(next & by-id, autoresort, single-call, keep-order)',
        'skipDown3+notify+flag','cancel->archive','done(autoresort)',
        'add(with party-size max & today-limit, autoresort, keep-order)',
        'getLimits','setLimit','setLimits',
        'query(people-limit)+ETA','lineReply/Push',
        'reorder: keep waiting/called relative order; Active â†’ Skipped â†’ Closed â†’ Others',
        'archive: move non-today rows to archive',
        'DAILY LIMIT: counts waiting+called+done'
      ]
    })).setMimeType(ContentService.MimeType.JSON);
  }

  const token = p.token || '';
  if (token !== PROP.getProperty('ADMIN_TOKEN')) {
    return ContentService.createTextOutput(JSON.stringify({ ok: false, reason: 'unauthorized' }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  const action = (p.action || 'list').trim();

  if (action === 'list') {
    const queue = getAll();
    const totals = {
      groups: getTotalWaitingGroups(),
      people: getTotalWaitingPeople(),
      used_people_today: getTotalUsedPeopleToday() // NEW: ä»Šæ—¥å·²ç´¯è¨ˆï¼ˆwaiting+called+doneï¼‰
    };
    const limits = {
      today_people_limit: getTodayPeopleLimit(),
      today_people_remaining: getTodayPeopleRemaining(),
      weekly: getDailyPeopleLimitMap()
    };
    return ContentService.createTextOutput(JSON.stringify({ ok: true, queue, totals, limits }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  if (action === 'call') {
    const id = (p.id || '').trim().toUpperCase();
    if (id) {
      const r = callById(id);
      return ContentService.createTextOutput(JSON.stringify({ ok: !!r.ok, result: r }))
        .setMimeType(ContentService.MimeType.JSON);
    } else {
      const next = callNext();
      return ContentService.createTextOutput(JSON.stringify({ ok: true, called: next }))
        .setMimeType(ContentService.MimeType.JSON);
    }
  }

  if (action === 'skip') {
    const id = (p.id || '').trim().toUpperCase();
    const r = id ? skipIdDownThree(id) : { ok: false, reason: 'missing_id' };
    return ContentService.createTextOutput(JSON.stringify({ ok: !!r.ok, result: r }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  if (action === 'cancel') {
    const id = (p.id || '').trim().toUpperCase();
    if (id) archiveById(id, 'cancelled');
    return ContentService.createTextOutput(JSON.stringify({ ok: true, cancelled: id || null, archived: !!id }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  if (action === 'done') {
    const id = (p.id || '').trim().toUpperCase();
    if (id) updateStatusById(id, 'done');
    return ContentService.createTextOutput(JSON.stringify({ ok: true, done: id || null }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  if (action === 'add') {
    const name = (p.name || '').trim();
    const size = parseInt((p.size || '0'), 10);
    const userId = (p.userId || '').trim(); // å¯ç•™ç©º
    const maxSize = getPartySizeMax();

    if (!name || !size || size <= 0) {
      return ContentService.createTextOutput(JSON.stringify({ ok:false, reason:'invalid_params' }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    if (size > maxSize) {
      return ContentService.createTextOutput(JSON.stringify({ ok:false, reason:'party_size_exceeds_max', max:maxSize }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    if (!canAcceptMoreToday(size)) {
      const limit = getTodayPeopleLimit();
      const used = getTotalUsedPeopleToday();
      const waiting = getTotalWaitingPeople();
      const remaining = Math.max(0, (limit || 0) - used);
      return ContentService.createTextOutput(JSON.stringify({
        ok:false,
        reason:'over_today_people_limit',
        limit,
        used_people: used,            // NEW
        waiting_people: waiting,      // ä¿ç•™ç›¸å®¹
        remaining
      })).setMimeType(ContentService.MimeType.JSON);
    }
    if (userId) {
      const exists = findByUser(userId);
      if (exists) {
        return ContentService.createTextOutput(JSON.stringify({ ok:false, reason:'already_in_queue', id:exists.id }))
          .setMimeType(ContentService.MimeType.JSON);
      }
    }
    const item = addWaiting(name, size, userId); // å…§å«è‡ªå‹•é‡æ’ï¼ˆæ–°é …åœ¨åº•éƒ¨ï¼‰
    const pos = positionOf(item.id);
    return ContentService.createTextOutput(JSON.stringify({ ok:true, created:item, position:pos }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  if (action === 'getLimits') {
    return ContentService.createTextOutput(JSON.stringify({
      ok: true,
      weekly: getDailyPeopleLimitMap(),
      today_people_limit: getTodayPeopleLimit(),
      today_people_remaining: getTodayPeopleRemaining(),
      used_people_today: getTotalUsedPeopleToday() // NEW
    })).setMimeType(ContentService.MimeType.JSON);
  }

  if (action === 'setLimit') {
    const weekday = Number(p.weekday);
    const people = Number(p.people);
    if (isNaN(weekday) || weekday < 0 || weekday > 6 || isNaN(people) || people <= 0) {
      return ContentService.createTextOutput(JSON.stringify({ ok:false, reason:'invalid_params' }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    const map = setDailyPeopleLimit(weekday, people);
    return ContentService.createTextOutput(JSON.stringify({ ok:true, weekly: map }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  if (action === 'setLimits') {
    try {
      const jsonStr = p.json || '';
      const map = setDailyPeopleLimitFromJson(jsonStr);
      return ContentService.createTextOutput(JSON.stringify({ ok:true, weekly: map }))
        .setMimeType(ContentService.MimeType.JSON);
    } catch (e) {
      return ContentService.createTextOutput(JSON.stringify({ ok:false, reason:String(e) }))
        .setMimeType(ContentService.MimeType.JSON);
    }
  }

  if (action === 'reorder') {
    reorderQueue();
    return ContentService.createTextOutput(JSON.stringify({ ok: true, reordered: true }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  if (action === 'archive') {
    const r = archiveOldRows();
    return ContentService.createTextOutput(JSON.stringify({ ok: true, archived: r }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  // æœªçŸ¥ action â†’ å›åˆ—è¡¨
  const queue = getAll();
  const totals = {
    groups: getTotalWaitingGroups(),
    people: getTotalWaitingPeople(),
    used_people_today: getTotalUsedPeopleToday()
  };
  const limits = {
    today_people_limit: getTodayPeopleLimit(),
    today_people_remaining: getTodayPeopleRemaining(),
    weekly: getDailyPeopleLimitMap()
  };
  return ContentService.createTextOutput(JSON.stringify({ ok: true, queue, totals, limits }))
    .setMimeType(ContentService.MimeType.JSON);
}
